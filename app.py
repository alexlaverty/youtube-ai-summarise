import argparse
import requests
import re
import sys
from typing import Tuple, List, Optional, Dict, Any
from pytubefix import YouTube
from pprint import pprint

# --- Configuration ---
# Makes it easier to change the Ollama endpoint or default model
DEFAULT_OLLAMA_URL = "http://localhost:11434/api/chat"
DEFAULT_OLLAMA_MODEL = "codeqwen:latest" # CHANGE THIS to your preferred Ollama model
DEFAULT_LANG_PREFERENCE = ['en', 'a.en'] # Prioritize manual English ('en'), then auto-generated ('a.en')

# --- Helper Functions ---

def clean_subtitle_text(srt_text: str) -> str:
    """
    Cleans SRT subtitle text by removing timestamps, sequence numbers,
    and common annotations like [Music] or [Applause]. Joins lines
    into a single coherent block of text.
    """
    # Remove sequence numbers
    cleaned = re.sub(r'^\d+\s*$', '', srt_text, flags=re.MULTILINE)
    # Remove timestamps
    cleaned = re.sub(r'\d{2}:\d{2}:\d{2},\d{3} --> \d{2}:\d{2}:\d{2},\d{3}\s*', '', cleaned, flags=re.MULTILINE)
    # Remove common annotations (e.g., [Music], [Applause], (Laughter)) - case insensitive
    cleaned = re.sub(r'\[.*?\]|\(.*?\)', '', cleaned, flags=re.IGNORECASE)
    # Remove HTML tags just in case (like <i>, <b>)
    cleaned = re.sub(r'<.*?>', '', cleaned)
    # Consolidate multiple newlines/spaces into single spaces
    cleaned = re.sub(r'\s+', ' ', cleaned).strip()
    return cleaned

# --- Core Functions ---

def extract_subtitles(youtube_url: str, lang_preference: List[str] = DEFAULT_LANG_PREFERENCE) -> Tuple[str, str]:
    """
    Extracts and cleans subtitles from a YouTube video.

    Args:
        youtube_url: The URL of the YouTube video.
        lang_preference: A list of language codes to try in order (e.g., ['en', 'a.en']).

    Returns:
        A tuple containing: (video_title, cleaned_subtitles_string).

    Raises:
        ValueError: If no suitable subtitles are found.
        RuntimeError: If there's an issue downloading or processing.
    """
    try:
        yt = YouTube(youtube_url)
        video_title = yt.title
        print(f"Processing video: '{video_title}'")
        print("Available captions:")
        pprint(yt.captions.keys()) # Show available language codes

        caption_to_fetch = None
        for lang_code in lang_preference:
            caption = yt.captions.get(lang_code)
            if caption:
                print(f"Found preferred caption: '{lang_code}'")
                caption_to_fetch = caption
                break # Stop searching once a preferred caption is found

        if not caption_to_fetch:
            # If no preferred captions found, try getting the first available one as a fallback
            if yt.captions:
                fallback_caption = list(yt.captions.values())[0]
                print(f"Warning: Preferred languages not found. Falling back to: '{fallback_caption.code}'")
                caption_to_fetch = fallback_caption
            else:
                raise ValueError("No subtitles available for this video in any language.")

        print(f"Fetching subtitles for language code: '{caption_to_fetch.code}'...")
        # generate_srt_captions() returns a string formatted in SRT
        raw_subtitles_srt = caption_to_fetch.generate_srt_captions()

        if not raw_subtitles_srt:
             raise ValueError(f"Subtitle generation for '{caption_to_fetch.code}' returned empty.")

        print("Cleaning subtitles...")
        cleaned_subtitles = clean_subtitle_text(raw_subtitles_srt)

        if not cleaned_subtitles:
            raise ValueError("Subtitles were empty after cleaning.")

        # Optional: Print a snippet of cleaned subtitles for verification
        # print("\n--- Cleaned Subtitle Snippet ---")
        # print(cleaned_subtitles[:500] + "...")
        # print("--- End Snippet ---\n")

        return video_title, cleaned_subtitles

    except Exception as e:
        # Catch specific pytube/network errors if needed, otherwise generalize
        raise RuntimeError(f"Failed to extract or clean subtitles from {youtube_url}: {e}")


def generate_key_points_with_ollama(
    subtitles: str,
    video_title: str,
    model_name: str = DEFAULT_OLLAMA_MODEL,
    ollama_url: str = DEFAULT_OLLAMA_URL
    ) -> str:
    """
    Sends cleaned subtitles to a local Ollama instance to generate key points.

    Args:
        subtitles: The cleaned subtitle text.
        video_title: The title of the YouTube video.
        model_name: The name of the Ollama model to use.
        ollama_url: The URL of the Ollama API endpoint.

    Returns:
        A string containing the key points generated by the model.

    Raises:
        RuntimeError: If communication with Ollama fails or the API returns an error.
    """
    try:
        # --- Optimized Prompt ---
        system_prompt = (
            "You are an expert assistant specialized in analyzing video transcripts. "
            "Your task is to identify and list the main key points discussed in a video, "
            "based *only* on the provided subtitles transcript. "
            "Format the output as a concise, easy-to-read bulleted list."
        )
        user_prompt = (
            f"I have the subtitles from a YouTube video titled \"{video_title}\". "
            "I don't have time to watch the video. Please analyze the following subtitle text "
            "and provide a bulleted list of the key points or main topics discussed. "
            "Focus on the core message and important information presented. Please return at least 10 points.\n\n"
            "--- Subtitle Transcript ---\n"
            f"{subtitles}\n"
            "--- End Transcript ---\n\n"
            "Key points:"
        )

        payload: Dict[str, Any] = {
            "model": model_name,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "stream": False,
             # Optional: Add parameters like temperature if needed
             # "options": {
             #    "temperature": 0.7
             # }
        }

        print(f"\nSending request to Ollama model '{model_name}' at {ollama_url}...")
        # Optional: Print payload for debugging (can be very long with subtitles)
        # print("Payload (excluding full subtitles):")
        # pprint({k: v if k != 'messages' else '[Messages with subtitles hidden]' for k, v in payload.items()})


        headers = {"Content-Type": "application/json"}
        response = requests.post(ollama_url, json=payload, headers=headers)
        response.raise_for_status()  # Raise an HTTPError for bad responses (4xx or 5xx)

        data = response.json()

        # Standard Ollama chat response structure
        if "message" in data and "content" in data["message"]:
            key_points = data["message"]["content"].strip()
            if not key_points:
                 return "Ollama returned an empty response."
            return key_points
        elif "error" in data:
             raise RuntimeError(f"Ollama API returned an error: {data['error']}")
        else:
            # Fallback if the structure is unexpected
            print("Warning: Unexpected response structure from Ollama:")
            pprint(data)
            return data.get("response", "No summary content found in response.") # Handle older /api/generate format just in case

    except requests.exceptions.RequestException as e:
        raise RuntimeError(f"Network error connecting to Ollama at {ollama_url}: {e}")
    except Exception as e:
        # Catch other potential errors (JSON decoding, etc.)
        raise RuntimeError(f"Failed to generate key points using Ollama: {e}")

# --- Main Execution ---

def main():
    parser = argparse.ArgumentParser(
        description="Extract YouTube subtitles and generate key points using Ollama.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter # Shows default values in help
    )
    parser.add_argument("-u", "--url", required=True, help="YouTube video URL")
    parser.add_argument(
        "-m", "--model",
        default=DEFAULT_OLLAMA_MODEL,
        help="Name of the Ollama model to use"
    )
    parser.add_argument(
        "--ollama-url",
        default=DEFAULT_OLLAMA_URL,
        help="URL for the Ollama API endpoint"
    )
    parser.add_argument(
        "-l", "--lang",
        nargs='+', # Allows multiple language codes
        default=DEFAULT_LANG_PREFERENCE,
        help="Preferred language codes for subtitles, in order of priority (e.g., 'en' 'a.en')"
    )
    args = parser.parse_args()

    try:
        print("--- Starting YouTube Subtitle Summarization ---")

        # 1. Extract and Clean Subtitles
        video_title, subtitles = extract_subtitles(args.url, lang_preference=args.lang)
        print(f"Subtitles extracted and cleaned successfully for '{video_title}'.")
        print(f"Total cleaned subtitle length: {len(subtitles)} characters.")

        # Check if subtitles seem reasonably long
        if len(subtitles) < 50: # Arbitrary short threshold
             print("Warning: The extracted subtitles seem very short. The summary might be limited.")
             if len(subtitles) == 0:
                 print("Error: Subtitles are empty after cleaning. Cannot proceed.")
                 sys.exit(1)


        # 2. Generate Key Points with Ollama
        print("\nGenerating key points with Ollama...")
        key_points = generate_key_points_with_ollama(
            subtitles=subtitles,
            video_title=video_title,
            model_name=args.model,
            ollama_url=args.ollama_url
        )

        # 3. Print Results
        print("\n--- Key Points from the Video ---")
        print(key_points)
        print("--- End of Key Points ---")

    except (ValueError, RuntimeError) as e:
        # Catch specific errors raised by our functions
        print(f"\nError: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        # Catch any other unexpected errors
        print(f"\nAn unexpected error occurred: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()